1-val ile var arasındaki fark nedir?

# Val ile var arasındaki fark kısaca değişken oluştururken değişkenin sadece okunabilir mi yoksa hem okunabilir hem değiştirilebilir mi olduğunu belirler.

2-Bir var değişkeni val gibi davranmasını nasıl sağlayabiliriz val kelimesini kullanmadan? Bunu neden yapmak isteriz? Örnek bir senaryo verin.

# Bir var değişkeni val gibi çalıştırmak için değişkeni private set yapmalıyız.Bunu yapma nedenimiz değişkeni başka sınıflarda değiştirilmesini önlemek.
Örnek senaryo olarak diyelim ki bir oyun geliştiriyorsunuz ve oyun karakterlerinin sağlık puanlarını yöneten bir sınıfınız var. Karakterlerin sağlık puanlarını saklamak için SaglikDurumu adında bir sınıf oluşturuyorsunuz. Ancak, bu sağlık puanlarının oyun içinde sadece bu sınıfta atanıp burda değişmesi lazım bu durumda kullanabiliriz.

3-"Değişmez" (Immutable) ve "Salt Okunur" (ReadOnly) kavramlarını açıklayın. val değişkenler neden aslında "değişmez" değil de "salt okunur" olarak açıklanmalıdır?

# Immutable dediğimiz yapıda değeri hiçbir şekilde değiştiremeyiz.ReadOnlyde ise değeri okuyabiliriz fakat set edemeyiz.Val değişkenlerde ise değişkenin get fonksiyonunda return ettiğimiz değer başka değiştirilebilir değerlerden oluşuyorsa bu değerleri farklı girdiğimiz her fonksiyon için bu val değerinden farklı cevap alırız bu yüzden de immutable olamaz.

4-"Tip Çıkarımı" (Type inference) kavramını açıklayın. Hangi durumlarda tip belirtmek kesin olarak gereklidir?

# Type inference(tip çıkarımı) kotlinde bir değişken oluştururken hangi türde olacağını belirtmediğimizde de IDE’nin otomatik olarak değişken türünü belirlemesidir.
Değerini daha sonradan vereceğimiz değişkenlere makinenin bellekte ne kadar yer ayırması gerektiğini bildirmemeiz için : ile değişken türünü bildirmeliyiz.

5-Kotlin'de tüm değişkenlerin sınıf olarak bulunması, "ilkel tip" (primitive type) olmadıkları anlamına gelir mi? Arka planda neler oluyor?

# Kotlinde primitive tipler aslında yoktur fakat sınıf şeklinde erişebiliyoruz.Arka planda sınıfların kullanımı da byte code'a çevrildikten sonra javadaki primitive tiplerle aynı oluyor ve performans kaybı da neredeyse olmuyor.

6-"Tip Güvenliği" (Type Safety) kavramını açıklayın.

# Tip güvenliği, değişken oluştururken değişkene hangi tür değişken olduğunu ":" ile yazmaya denir.

7-Bir değişkeni nullable yapmak için ne yapmalıyız?

# Değişkenin tanımlarken tip değerinin yanına "?" Koyarsak ve null'a eşitlersek değişken nulable olur.

8-"Null Güvenliği" (Null Safety) kavramını açıklayın.

# Null güvenliği kullandığımız değişkenlerin null olup olmadığını daha rahat anlayabilmemiz ve buna göre işlem yapabilmemize denir.

9-Bir değişkene null değer atanır ve tip belirtilmezse Kotlin bu değişkeni nasıl yorumlar?

# Kotlin bu değerin herhangi bir değişkene sahip olabileceğini düşünür bu yüzden de Nothing? Olarak yorumlar.

10-İlkel bir değişkenin nullable olması ile null değer alamaması arasında bellek yönetimi açısından nasıl farklar vardır?

# İlkel değişken null değer alamazsa, o değişkenin bellekte bir değer için ayrılmış bir alanı vardır ve bu alan değer alabilir. Ancak nullable bir ilkel değişken null değer alabilir ve bu durumda bellekte ekstra bir alan ayırmaz. Bunun yerine, null değer olması durumunda sadece bir referans, yani bellekta bir adres, saklanır. Dolayısıyla, nullable bir değişkenin bellek kullanımı, null değer olmayan bir ilkel değişkene kıyasla daha verimlidir.

11-Nullable bir değişkenin bir değere sahip olması ile null olması arasında bellek yönetimi açısından nasıl bir fark vardır? Null değer almış bir değişken bellekte yer kaplamaz diyebilir miyiz?

# Nullable bir değişken bir değere sahip olduğunda bellekte onun için yer tutulur fakat null olduğunda yer tutulmaz.Evet null değer almış değişken yer kaplamaz.

12-Nullable bir değişkenle çalışırken hangi operatörleri kullanırız? Bu operatörlerin kullanım farkları nelerdir? Hangisini ne zaman kullanmak daha anlamlıdır?

# Nullable değişkenlerle çalışırken ?. Veya !!. Kullanırız ?. Basitçe bir if sorgusudur değer full değilse yap gibi,!! ise değer her ne olursa olsun işlemi yap bunun sonucu crash oluşabilir. Bir uygulamada hayati değere sahip bir olayda !! Kullanmak eğer değer yoksa hayati sonuçlar çıkmasını engeller ve crash verir.Önemsiz denebilecek yerlerde ise .? Kullanarak değer dönmezse bile uygulama çökmez ve önemli bir sonuç oluşmaz.

13-Kaç farklı tipte "number" sınıfı miras alan "alt sınıf" (child class) vardır? Bunların değer aralıkları neden önemlidir?

# Byte,Short,Int,Long,Double,Float olmak üzere 6 tipte alt sınıf vardır.
Değer aralıkları bellekte kaplanan alanı temsil eder ve büyük projelerde verimsizlik yaratabilir.

14-Eğer bir değişkene tip belirtimi yapılmaz ve bir değer atanırsa, Kotlin tip çıkarımını nasıl yapar?

# Int değer aralığı veya daha alt gruplardaysa int büyüklerinde ise Long olarak işaretler.

15-Float değişken oluştururken F ve f harfleri varken, Long değişken oluştururken neden küçük l harfi yoktur?

# Küçük l harfi bazı fontlarda "ı" veya "1" e benzediğinden sadece büyük L ile işlem yapılır.

16-Tek duyarlıklı (Single precision) ve Çift duyarlıklı (Double precision) kavramlarını açıklayın.

# Tek duyarlıklı sayılar, daha az bellek kullanır ve daha hızlı işlem yaparlar, ancak daha az doğruluk sağlarlar. Öte yandan, çift duyarlıklı sayılar daha fazla bellek alanı gerektirir ve daha yavaş işlem yaparlar, ancak daha yüksek doğruluk sağlarlar.

17-Double ve Float değişkenlerle çalışırken ondalık ayıracı olarak hangi işaretler kullanılır? Bu ayıraçların kullanımında nelere dikkat etmek gerekir?

# Ayıraç olarak (.) veya (,) kullanılır ve kullanırken gelen verinin ayırma şekline bakarak hatalı sonuçlar oluşmasını engellemeliyiz.

18-Double ve Float değişkenler ondalık kısımda kaç basamağa kadar işlem yaparlar? Bu sınırın üzerinde gelen ondalık bilgileri için nasıl davranırlar? Hangi durumlar için Float ve hangi durumlar için Double kullanılmalıdır?

# Float veri tipinde 6-7 basamağa kadar işlem yaparken Double 15-16 basamağa kadar işlem yapabilir.Bu sınırlardan daha büyük olursa yuvarlayarak belirli basamak sayısında yaklaşık bir değer üretir.










